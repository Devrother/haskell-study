# CIS194 - Week 8

## IO

### The problem with purity

하스켈은 lazy하기 때문에 pure하다. 이것은 중요한 두가지를 의미한다.
1. 함수는 함수 이외의 것으로 인한 어떠한 영향이 없어야 한다. (ex. 함수는 화면에 출력하면 안된다.) 함수는 함수 자체의 결과값**만** 계산해야 한다.
2. 함수는 외부의 도구에 의존적이지 않아야 한다. (ex. 함수는 키보드 입력이나 파일/네트워크 입력을 받을 수 없다.) 함수는 함수 자체의 입력(인자)에**만** 의존적이어야 한다. 즉, 함수는 같은 입력값에 대해서는 같은 출력을 반환해야 한다.

하지만 이러한 도구들을 사용하고 싶을 때가 분명 있다! 만약 Haskell으로 할 수 있는 것이 단순히 ghci를 통해 계산하는 함수를 하는 것이 전부라면, 학문적으로는 흥미로울 수 있으나 전혀 실용적이지 않을 것이다.

사실 Haskell로 이러한 것들을 하는 것은 가능하다. 하지만 다른 언어들과 매우 달라 보인다.

### The IO type

문제의 해답은 `IO`라 부르는 특별한 타입이다. `IO a` 타입의 값들은 효과적인 계산에 대한 서술이다. 가능한 경우 I/O 연산을 실행하거나, 결국 `a`라는 타입의 값을 생성한다. `IO a` 타입의 값은 그 자체로 어떠한 효과에 대해서 안전하다. 이것은 효과적인 계산에 대한 서술일 뿐이다. 이것에 대해 생각해볼 수 있는 방법 중 하나는 **first-class** 명령형 프로그래밍이다.

아래 그림과 같이, 우리가 케이크를 갖고 있다고 가정해보자.

```haskell
c :: Cake

```

평범하고 심플한 맛있는 케이크를 갖게 되었다.

![](img/cake.jpg)

반대로 우리가 레시피를 갖고 있다고 가정해보자.

```haskell
r :: Recipe Cake
```

레시피를 갖게 되었다. 케이크를 어떻게 만드는지에 대한 설명이 적혀있는 종이조각 말이다.

![](img/recipe.gif)

실제로 케이크를 갖고 있는 것뿐만 아니라, 레시피까지 갖고 있다는 것은 다른 어떠한 것에 영향을 미치지 않는다. 단순히 레시피가 손 안에 있다는 것만으로, 오븐이 가열되거나 밀가루가 계량되어지거나 하는 일은 없다. 케이크를 만드는 것은 레시피대로 **행해져야** 한다. (밀가루가 뿌려지거나, 재료가 혼합되거나 오븐이 가열되는 것 등 말이다.)

이와 같이 `IO a` 타입의 값은 그저 `a` 타입의 값을 만드는 **레시피**일 뿐이다. (그리고 이에 따라 조금의 영향이 있을 수 있다.) 다른 값들과 같이 인자로 전달될 수 있으며 함수의 결과값으로 반환될 수 있고, data structure에 저장될 수 있다. 그리고 (곧 보게 될테지만) 다른 `IO` 값들과 결합해서 더욱 복잡한 레시피를 만들 수도 있다.

그렇다면 `IO` 타입의 값은 어떻게 **실행**될까? 단 한가지 방법이 있다. Haskell 컴파일러가 아래와 같은 특별한 값을 찾는다.

```haskell
main :: IO ()
```

위 코드를 통해 런타임으로 전달되고 실행된다. 그게 전부다! 즉 Haskell 런타임이란, 요리를 할 수 있는 마스터 셰프라고 보면 된다. 물론 `main`은 더 복잡할 수 있으며 많은 작은 `IO` 계산들로 구성될 수 있다.

자 이제 작성해보자! 우리는 다음과 같은 함수를 쓸 수 있다.

```haskell
putStrLn :: string -> IO ()
```

이 함수는 `String`을 받게 되면 **(실행될 때) 화면에 해당 `String`을 출력하는 `IO` 계산**을 반환한다. 그래서 우리는 `Hello.hs`에서 간단히 다음과 같이 함수를 가져다 쓸 수 있다.

```haskell
module Hello where

main = putStrLn "Hello Onsuk!"
```

그리고 명령 프롬프트에서 `runhaskell Hello.hs` 명령어를 입력하면 화면에 메시지가 출력된다.

> 난 **stack**을 사용했기 때문에 `stack runghc Hello.hs`을 입력하면 된다.

혹은 `ghc --make Hello.hs`를 사용하면 Hello(윈도우에서는 Hello.exe)라는 실행 가능한 파일을 얻을 수 있다.

### There is no String "inside" an IO String

Haskell을 처음 접한 많은 사용자들이 "`IO String`을 어떻게 `String`으로 바꾸나요?" 혹은 "`IO String`에서 어떻게 `String`을 가져오죠?" 라고 질문한다. 이 질문 자체에 문제가 있음을 알아야 한다. `IO String` 타입의 값은 단순히 어떠한 계산에 대한 서술이다. 즉, `String`을 생성하는 레시피이다. `String`(케이크)을 생성하기 위해서는 꼭 계산(레시피)을 실행해야 한다. 그렇게 할 수 있는 유일한 방법은 `main`을 통해 Haskell 런타임에게 제공하는 것이다.

### Combining IO

지금까지를 보아 알 수 있듯이, `IO` 계산을 더욱 큰 하나로 결합하는 방법이 필요하다.

가장 간단한 방법은 두개의 `IO` 계산을 '**and then**'이라고 부르는 `>>` 연산자로 결합하는 것이다. 다음과 같은 타입을 갖고 있다.

```haskell
(>>) :: IO a -> IO b -> IO b
```

이것은 단순히 **두개의 `IO` 계산을 순서대로 실행하는 `IO` 계산**을 생성한다. 첫번째 계산의 결과값은 무시되는 것을 유의해야 한다. 우리는 그 효과에 대해서만 관심이 있다. 예를 들어,

```haskell
main = putStrLn "Hello" >> putStrLn "world!"
```

`"do this; do this; do this;"` 형태의 코드와 같이 결과값이 중요하지 않는 코드에서는 정상적으로 동작한다. 하지만 일반적인 경우 이것은 불충분하다. 첫 번째 계산에서 계산결과를 버리지 않으려면 어떻게 하면 되는걸까?

문제 해결의 첫번째 시도는 `IO a -> IO b -> IO (a, b)` 형태의 타입을 갖는 무언가일 것이다. 하지만 이것 또한 충분하지 않다. 이유는 두 번째 계산이 첫 번째 계산에게 의존적이기 원하기 때문이다. 예를 들어 사용자에게 정수를 입력받고, 받은 정수를 하나 더 출력하고 싶다고 가정해보자. 이러한 경우에 (화면에 출력하는 역할을 담당하는) 두번째 계산은 첫번째 결과에 의해 달라진다.

대신에, '**bind**'라고 부르는 `(>>=)` 연산자가 있다. 다음과 같은 타입을 갖고 있다.

```haskell
(>>=) :: IO a -> (a -> IO b) -> IO b
```

처음엔 머리를 쥐어짤만큼 어려울 것이지만 살펴보도록 하자. `(>>=)`는 다음과 같은 두개의 인자를 받는다.
- `a` 타입의 값을 생성하는 계산
- `a` 타입의 값을 기반으로 두 번째 계산을 계산하는 함수

`(>>=)`의 결과값은
- 어떠한 계산이다. (첫번째 계산의 결과값을 통해 다음 수행할 것을 결정하고, 그것을 수행한다.)

예를 들어, 사용자에게 숫자를 입력받고 (+1)한 숫자를 화면에 출력하는 프로그램을 작성할 수 있다. `readLn :: Read a => IO a`는 사용자의 입력을 받아들여서 `Read` 타입의 인스턴스로 변환해주는 계산이다.

```haskell
main :: IO ()
main = putStrLn "Please enter a number: " >> (readLn >>= (\n -> putStrLn (show (n+1))))
```

물론 이것은 덜떨어진 코드이지만, 더 나은 방법이 존재한다. 추후에 다뤄보도록 할 예정이다.

### Record syntax

#### 강의에서 다루지는 않았지만, Homework8을 해결하기 위한 추가적인 자료 제공이다.

다음과 같은 타입이 있다고 가정해보자.

```haskell
data D = C T1 T2 T3
```

다음과 같이 이것을 **record syntax**를 이용해서도 선언할 수 있다.

```haskell
data D = C { 
    field1 :: T1, 
    field2 :: T2, 
    field3 :: T3 
}
```

`C` 컨스트럭터 안의 각 필드의 타입 뿐만 아니라 이름까지 정의되어 있다. 새로운 버전의 `D`는 구 버전의 `D`와 똑같은 방법으로 쓸 수 있다. (특히 `C v1 v2 v3`와 같이 패턴 매칭이나 data construct 또한 여전히 가능하다.) 물론, 추가적인 장점이 있다.

- 각 필드 이름은 자동으로 프로젝션 함수가 되며, 필드에 대한 값을 `D` 타입에서 가져온다. 예를 들어 다음과 같은 `field2`라는 함수를 살펴보도록 하자.

```haskell
field2 :: D -> T2
```

이전에 `field2`에 대해 다음과 같이 직접 작성(패턴매칭)해서 구현해야 했다.

```haskell
field2 (C _ f _) = f
```

여러개의 필드를 가진 데이터 타입을 이용하면 수많은 보일러플레이트 코드를 제거할 수 있다!

- `D` 타입 값의 constructing, modifying, 매턴매칭에 대한 특정한 문법이 있다. `D` 타입 값을 다음과 같이 construct할 수 있다.

```haskell
C { field3 = ...,
    field1 = ...,
    field2 = ...
}
```

`...`로 채워진 expression 부분을 제대로 된 타입으로 채우면 된다. 필드를 어떠한 순서로 명시하던 상관이 없다는 점을 유의하도록 하자. 예를 들어, `d :: D`라는 값이 있다고 하자. 우리는 `d`라는 값을 modify하려고 할 때 다음과 같이 작성할 수 있다.

```haskell
d { field3 = ... }
```

물론 modify가 실제로 `d`를 변경한다는 뜻은 아니다. `field3` 필드가 주어진 값으로 대체 된 경우를 제외하고는, d와 동일한 D 유형의 새로운 값을 구성하는 것을 의미한다.

결국 우리는 `D` 타입 값에 대한 패턴매칭을 다음과 같이 할 수 있다.

```haskell
foo (C { field1 = x }) = ... x ...
```

다른 필드는 무시하고 `field1` 필드만 `x`로 매칭한다. (물론 `x` 대신 다른 패턴을 넣을 수도 있다.)